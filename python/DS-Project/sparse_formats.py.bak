# # sparse_formats.py
# from dataclasses import dataclass
# from typing import List, Tuple, Dict
# import json, struct
#
#
# @dataclass
# class COO:
#     shape: Tuple[int, int]
#     data: List[Tuple[int, int, int]]  # (r,c,val)
#
#     def to_json(self, path):
#         with open(path, "w") as f:
#             json.dump(
#                 {"format": "COO", "shape": list(self.shape), "data": self.data}, f
#             )
#
#     @staticmethod
#     def from_json(path):
#         with open(path, "r") as f:
#             o = json.load(f)
#         return COO(tuple(o["shape"]), [tuple(x) for x in o["data"]])
#
#     def to_dense(self, dtype=int):
#         import numpy as np
#
#         H, W = self.shape
#         a = np.zeros((H, W), dtype=dtype)
#         for r, c, v in self.data:
#             a[r, c] = v
#         return a
#
#     @staticmethod
#     def from_dense(arr):
#         import numpy as np
#
#         H, W = arr.shape
#         data = []
#         for r in range(H):
#             for c in range(W):
#                 v = int(arr[r, c])
#                 if v != 0:
#                     data.append((r, c, v))
#         return COO((H, W), data)
#
#     def to_csr(self):
#         # produce (row_ptr, col_idx, values)
#         H, W = self.shape
#         row_ptr = [0] * (H + 1)
#         col_idx = []
#         values = []
#         # ensure sorted by row
#         data_sorted = sorted(self.data, key=lambda x: (x[0], x[1]))
#         cur_row = 0
#         count = 0
#         di = 0
#         for r, c, v in data_sorted:
#             while cur_row < r:
#                 row_ptr[cur_row + 1] = count
#                 cur_row += 1
#             col_idx.append(c)
#             values.append(v)
#             count += 1
#         # finish row_ptr
#         while cur_row < H:
#             row_ptr[cur_row + 1] = count
#             cur_row += 1
#         return CSR(self.shape, row_ptr, col_idx, values)
#
#     def to_binary(self, path):
#         # fixed header: magic 'SPCO' + H W N (ints 4 bytes) then N entries of (r:int32,c:int32,v:uint8)
#         with open(path, "wb") as f:
#             f.write(b"SPCO")
#             H, W = self.shape
#             N = len(self.data)
#             f.write(struct.pack("<III", H, W, N))
#             for r, c, v in self.data:
#                 f.write(struct.pack("<IIb", r, c, v))
#
#
# @dataclass
# class CSR:
#     shape: Tuple[int, int]
#     row_ptr: List[int]
#     col_idx: List[int]
#     values: List[int]
#
#     def to_coo(self):
#         H, W = self.shape
#         data = []
#         for r in range(H):
#             start = self.row_ptr[r]
#             end = self.row_ptr[r + 1]
#             for i in range(start, end):
#                 data.append((r, self.col_idx[i], self.values[i]))
#         return COO(self.shape, data)
#
#     def to_json(self, path):
#         with open(path, "w") as f:
#             json.dump(
#                 {
#                     "format": "CSR",
#                     "shape": list(self.shape),
#                     "row_ptr": self.row_ptr,
#                     "col_idx": self.col_idx,
#                     "values": self.values,
#                 },
#                 f,
#             )
#
#     @staticmethod
#     def from_json(path):
#         import json
#
#         with open(path, "r") as f:
#             o = json.load(f)
#         return CSR(tuple(o["shape"]), o["row_ptr"], o["col_idx"], o["values"])
#
#
# class DOK:
#     def __init__(self, shape):
#         self.shape = shape
#         self.map: Dict[Tuple[int, int], int] = {}
#
#     @staticmethod
#     def from_coo(coo: COO):
#         dok = DOK(coo.shape)
#         for r, c, v in coo.data:
#             dok.map[(r, c)] = v
#         return dok
#
#     def to_coo(self):
#         data = [(r, c, v) for (r, c), v in self.map.items()]
#         return COO(self.shape, data)
#
#     def set(self, r, c, v):
#         if v == 0:
#             self.map.pop((r, c), None)
#         else:
#             self.map[(r, c)] = v
#
#     def get(self, r, c):
#         return self.map.get((r, c), 0)


# sparse_formats.py
from dataclasses import dataclass
from typing import List, Tuple, Dict, Optional
import json, struct
import numpy as np
import os


@dataclass
class COO:
    shape: Tuple[int, int]
    data: List[Tuple[int, int, int]]  # (r,c,val)

    def to_json(self, path: str):
        with open(path, "w") as f:
            json.dump(
                {"format": "COO", "shape": list(self.shape), "data": self.data}, f
            )

    @staticmethod
    def from_json(path: str):
        with open(path, "r") as f:
            o = json.load(f)
        return COO(tuple(o["shape"]), [tuple(x) for x in o["data"]])

    def to_dense(self, dtype=np.uint8):
        H, W = self.shape
        arr = np.zeros((H, W), dtype=dtype)
        for r, c, v in self.data:
            arr[r, c] = v
        return arr

    @staticmethod
    def from_dense(arr: np.ndarray):
        # fast: use numpy.nonzero
        if not isinstance(arr, np.ndarray):
            arr = np.array(arr)
        nz = np.nonzero(arr)
        rows = nz[0].tolist()
        cols = nz[1].tolist()
        vals = arr[nz].astype(int).tolist()
        data = list(zip(rows, cols, vals))
        return COO((int(arr.shape[0]), int(arr.shape[1])), data)

    def to_csr(self):
        H, W = self.shape
        # assume data is unsorted; we will sort by row then col
        if not self.data:
            return CSR(self.shape, [0] * (H + 1), [], [])
        data_sorted = sorted(self.data, key=lambda x: (x[0], x[1]))
        col_idx = []
        values = []
        row_ptr = [0] * (H + 1)
        cur_row = 0
        count = 0
        for r, c, v in data_sorted:
            while cur_row < r:
                row_ptr[cur_row + 1] = count
                cur_row += 1
            col_idx.append(c)
            values.append(v)
            count += 1
        while cur_row < H:
            row_ptr[cur_row + 1] = count
            cur_row += 1
        return CSR(self.shape, row_ptr, col_idx, values)

    def to_binary(self, path: str):
        # Format:
        # header: magic 'SPCO' (4 bytes) | H (uint32) | W (uint32) | N (uint32)
        # entries: N * (r:uint32 | c:uint32 | v:uint8)
        with open(path, "wb") as f:
            f.write(b"SPCO")
            H, W = self.shape
            N = len(self.data)
            f.write(struct.pack("<III", int(H), int(W), int(N)))
            for r, c, v in self.data:
                f.write(struct.pack("<IIB", int(r), int(c), int(v)))

    @staticmethod
    def from_binary(path: str):
        with open(path, "rb") as f:
            magic = f.read(4)
            if magic != b"SPCO":
                raise ValueError("Not a SPCO binary file")
            H, W, N = struct.unpack("<III", f.read(12))
            data = []
            for _ in range(N):
                r, c, v = struct.unpack("<IIB", f.read(9))
                data.append((int(r), int(c), int(v)))
        return COO((H, W), data)


@dataclass
class CSR:
    shape: Tuple[int, int]
    row_ptr: List[int]
    col_idx: List[int]
    values: List[int]

    def to_coo(self):
        H, W = self.shape
        data = []
        for r in range(H):
            start = self.row_ptr[r]
            end = self.row_ptr[r + 1]
            for i in range(start, end):
                data.append((r, self.col_idx[i], self.values[i]))
        return COO(self.shape, data)

    def to_json(self, path: str):
        with open(path, "w") as f:
            json.dump(
                {
                    "format": "CSR",
                    "shape": list(self.shape),
                    "row_ptr": self.row_ptr,
                    "col_idx": self.col_idx,
                    "values": self.values,
                },
                f,
            )

    @staticmethod
    def from_json(path: str):
        with open(path, "r") as f:
            o = json.load(f)
        return CSR(tuple(o["shape"]), o["row_ptr"], o["col_idx"], o["values"])

    def to_binary(self, path: str):
        # header: magic 'SPCS' | H W rows Ncols Nvals
        # store H (uint32), W (uint32), rows (uint32 = H+1), Ncols (uint32), Nvals (uint32)
        with open(path, "wb") as f:
            f.write(b"SPCS")
            H, W = self.shape
            rows = len(self.row_ptr)
            ncols = len(self.col_idx)
            nvals = len(self.values)
            f.write(
                struct.pack("<IIIII", int(H), int(W), int(rows), int(ncols), int(nvals))
            )
            # row_ptr: rows * uint32
            f.write(struct.pack("<" + "I" * rows, *[int(x) for x in self.row_ptr]))
            # col_idx: ncols * uint32
            f.write(struct.pack("<" + "I" * ncols, *[int(x) for x in self.col_idx]))
            # values: nvals * uint8
            f.write(struct.pack("<" + "B" * nvals, *[int(x) for x in self.values]))

    @staticmethod
    def from_binary(path: str):
        with open(path, "rb") as f:
            magic = f.read(4)
            if magic != b"SPCS":
                raise ValueError("Not a SPCS CSR binary file")
            H, W, rows, ncols, nvals = struct.unpack("<IIIII", f.read(20))
            row_ptr = list(struct.unpack("<" + "I" * rows, f.read(4 * rows)))
            col_idx = list(struct.unpack("<" + "I" * ncols, f.read(4 * ncols)))
            values = list(struct.unpack("<" + "B" * nvals, f.read(nvals)))
        return CSR((H, W), row_ptr, col_idx, values)


class DOK:
    def __init__(self, shape: Tuple[int, int]):
        self.shape = shape
        self.map: Dict[Tuple[int, int], int] = {}

    @staticmethod
    def from_coo(coo: COO):
        dok = DOK(coo.shape)
        for r, c, v in coo.data:
            dok.map[(r, c)] = v
        return dok

    def to_coo(self):
        data = [(r, c, v) for (r, c), v in self.map.items()]
        return COO(self.shape, data)

    def set(self, r: int, c: int, v: int):
        if v == 0:
            self.map.pop((r, c), None)
        else:
            self.map[(r, c)] = int(v)

    def get(self, r: int, c: int):
        return self.map.get((r, c), 0)


# Helper: read binary as COO (used in webapp)
def read_coo_binary(path: str) -> COO:
    return COO.from_binary(path)


# small utility for file size
def file_size(path: str) -> int:
    return os.path.getsize(path)
